import { EsriTypeMap, MapChild } from '../utilities/GIS';
import { ConstructorInstance, Diff, FirstConstructorArgument, Optional, Remove } from '../utilities/Types';

// to see how to properly couple the DOM widgets to HTML generated by React.
export type WidgetConstructorKeys = ({
    [T in keyof EsriTypeMap]: EsriTypeMap[T] extends { new(...params: never[]): __esri.Widget } ? T : never;
})[keyof EsriTypeMap];
type WidgetPropertiesTypeMap = {
    [T in WidgetConstructorKeys]: Diff<FirstConstructorArgument<EsriTypeMap[T]>, undefined>
};
export type GenericWidgetConstructorKeys = Diff<WidgetConstructorKeys, 'esri/widgets/Expand'>;

type BaseWidgetProperties<T extends WidgetConstructorKeys> = SpecializedWidgetProperties<T> & {
    type: T;
    widgetProperties?: Optional<Remove<WidgetPropertiesTypeMap[T], keyof WidgetProperties<T, any> | SpecializedWidgetPropertyRemover<T>>>;
    init?: (widget: ConstructorInstance<EsriTypeMap[T]>) => void;
    id: string;
}

export type DOMWidgetProperties<T extends WidgetConstructorKeys> = BaseWidgetProperties<T> & {
    mapId: string;
    domId?: string;
    className?: string;
    style?: React.CSSProperties;
    position?: never;
}

export type MapWidgetProperties<T extends WidgetConstructorKeys, U extends boolean = false> = BaseWidgetProperties<T> & {
    position: __esri.UIAddComponent['position'];
    mapId?: never;
    domId?: never;
    className?: never;
    style?: never;
    expandable?: U;
    expandProperties?: U extends true ? Optional<Remove<__esri.ExpandProperties, 'content'>> : never;
};

interface SpecializedWidgetPropertyTypeMap {
    'esri/widgets/Sketch': { layer: string };
    'esri/widgets/Editor': { layers?: string[] };
    'esri/widgets/FeatureTable': { layer: string };
}
export type SpecializedWidgetProperties<T extends WidgetConstructorKeys> = T extends keyof SpecializedWidgetPropertyTypeMap ? SpecializedWidgetPropertyTypeMap[T] : {};

interface SpecializedWidgetPropertyRemoverTypeMap {
    'esri/widgets/Editor': 'layerInfos';
}
type SpecializedWidgetPropertyRemover<T extends WidgetConstructorKeys> = T extends keyof SpecializedWidgetPropertyRemoverTypeMap ? SpecializedWidgetPropertyRemoverTypeMap[T] : never;

export type WidgetProperties<T extends WidgetConstructorKeys, U extends boolean = false> = MapWidgetProperties<T, U> | DOMWidgetProperties<T>;
export type MapChildWidgetProperties<T extends WidgetConstructorKeys, U extends boolean = false> = WidgetProperties<T, U> & MapChild;
// eslint-disable-next-line
export const WidgetProperties = {
    isMapWidget: <T extends WidgetConstructorKeys, U extends boolean>(props: WidgetProperties<T, U>): props is MapWidgetProperties<T, U> & MapChild => {
        return typeof (props as MapWidgetProperties<T, U>).position !== 'undefined';
    },

    isExpandableMapWidget: <T extends WidgetConstructorKeys>(props: WidgetProperties<T, boolean>): props is MapWidgetProperties<T, true> & MapChild => {
        return WidgetProperties.isMapWidget(props) && !!props.expandable;
    },

    isDOMWidget: <T extends WidgetConstructorKeys, U extends boolean = false>(props: WidgetProperties<T, U>): props is DOMWidgetProperties<T> => {
        return typeof (props as DOMWidgetProperties<T>).mapId === 'string';
    }
};

export interface WidgetQueueItem {
    id: string;
    view: __esri.View;
    getWidget: () => __esri.Widget | HTMLElement | string;
    position: __esri.UIAddComponent['position'];
    ready: boolean;
    cancel: () => void;
}

export interface WidgetState {
    status: 'loading' | 'loaded' | 'error';
    queueInfo: { id: string, onReady: () => void };
    widget?: __esri.Widget;
    readonly domId?: string;
}